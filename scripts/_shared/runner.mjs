#!/usr/bin/env node

/**
 * Shared script runner utility
 * Provides common functionality for running scripts in each category
 */

import { spawn } from 'node:child_process'
import fs from 'node:fs/promises'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

/**
 * Run a script file
 * @param {string} scriptPath - Path to the script file
 * @returns {Promise<void>}
 */
export function runScript(scriptPath) {
  return new Promise((resolve, reject) => {
    const child = spawn('node', [scriptPath], {
      stdio: 'inherit',
      shell: false,
    })

    child.on('close', code => {
      if (code === 0) {
        resolve()
      } else {
        reject(new Error(`Script exited with code ${code}`))
      }
    })

    child.on('error', error => {
      reject(error)
    })
  })
}

/**
 * Get the directory path for a category
 * @param {string} categoryDir - The category directory (e.g., 'generate', 'validate', 'fetch')
 * @returns {string} - Full path to the category directory
 */
export function getCategoryDir(categoryDir) {
  return path.join(__dirname, '..', categoryDir)
}

/**
 * Discover all scripts in a category directory
 * @param {string} categoryDir - The category directory path
 * @returns {Promise<Object>} - Map of script names to script files
 *
 * Script names are generated by:
 * 1. Removing .mjs extension
 * 2. If filename starts with category prefix (e.g., "validate-"), remove it
 * 3. Otherwise, use the full filename without extension
 *
 * Examples:
 * - "validate-manifests.mjs" in validate/ -> "manifests"
 * - "sort-manifest-fields.mjs" in refactor/ -> "sort-manifest-fields" (no prefix)
 * - "refactor-sort-fields.mjs" in refactor/ -> "sort-fields" (prefix removed)
 */
async function discoverScripts(categoryDir) {
  const scripts = {}

  try {
    const entries = await fs.readdir(categoryDir, { withFileTypes: true })

    for (const entry of entries) {
      // Skip index.mjs and non-.mjs files
      if (entry.isFile() && entry.name.endsWith('.mjs') && entry.name !== 'index.mjs') {
        // Generate script name from filename (without .mjs extension)
        const baseName = entry.name.replace(/\.mjs$/, '')

        // Remove category prefix if present (e.g., "generate-", "validate-", "fetch-")
        // If filename doesn't start with prefix, use full name without extension
        const categoryPrefix = `${path.basename(categoryDir)}-`
        const scriptName = baseName.startsWith(categoryPrefix)
          ? baseName.slice(categoryPrefix.length)
          : baseName

        scripts[scriptName] = entry.name
      }
    }
  } catch (error) {
    console.error(`Error discovering scripts in ${categoryDir}:`, error.message)
  }

  return scripts
}

/**
 * Filter scripts based on includes/excludes
 * @param {Object} scripts - Map of script names to script files
 * @param {string[]} [includes] - Script names to include (if specified, only these will run)
 *                                Use script name without .mjs extension (e.g., 'sort-manifest-fields', 'manifests')
 * @param {string[]} [excludes] - Script names to exclude
 *                                 Use script name without .mjs extension (e.g., 'sort-manifest-fields', 'github-stars')
 * @returns {Object} - Filtered scripts map
 */
function filterScripts(scripts, includes, excludes) {
  let filtered = { ...scripts }

  // Apply includes filter
  if (includes && includes.length > 0) {
    filtered = {}
    for (const name of includes) {
      if (scripts[name]) {
        filtered[name] = scripts[name]
      } else {
        console.warn(`‚ö†Ô∏è  Script "${name}" specified in includes but not found`)
      }
    }
  }

  // Apply excludes filter
  if (excludes && excludes.length > 0) {
    for (const name of excludes) {
      if (filtered[name]) {
        delete filtered[name]
      }
    }
  }

  return filtered
}

/**
 * Main runner function
 * @param {Object} config - Configuration object
 * @param {string} config.categoryName - Category name (e.g., 'generate', 'validate', 'fetch')
 * @param {string[]} [config.includes] - Script names to include (without .mjs suffix, e.g., 'manifests', 'urls')
 * @param {string[]} [config.excludes] - Script names to exclude (without .mjs suffix, e.g., 'github-stars')
 */
export async function runCategoryScripts(config) {
  const { categoryName, includes, excludes } = config
  const categoryDir = getCategoryDir(categoryName)

  // Auto-discover scripts in the category directory
  const allScripts = await discoverScripts(categoryDir)

  if (Object.keys(allScripts).length === 0) {
    console.error(`‚ùå No scripts found in ${categoryName}/ directory`)
    process.exit(1)
  }

  // Filter scripts based on includes/excludes
  const scripts = filterScripts(allScripts, includes, excludes)

  if (Object.keys(scripts).length === 0) {
    console.error(`‚ùå No scripts to run after filtering`)
    process.exit(1)
  }

  const scriptName = process.argv[2]

  if (scriptName) {
    // Run specific script (bypasses includes/excludes filter)
    const scriptFile = allScripts[scriptName]
    if (!scriptFile) {
      console.error(`‚ùå Unknown script: ${scriptName}`)
      console.error(`\nAvailable scripts:`)
      Object.keys(allScripts)
        .sort()
        .forEach(name => {
          console.error(`  - ${name}`)
        })
      process.exit(1)
    }

    console.log(`üöÄ Running ${scriptName}...\n`)
    try {
      await runScript(path.join(categoryDir, scriptFile))
      console.log(`\n‚úÖ ${scriptName} completed successfully`)
    } catch (error) {
      console.error(`\n‚ùå ${scriptName} failed:`, error.message)
      process.exit(1)
    }
  } else {
    // Run all filtered scripts in alphabetical order
    console.log(`üöÄ Running all ${categoryName} scripts...\n`)

    const order = Object.keys(scripts).sort()

    for (const name of order) {
      const scriptFile = scripts[name]

      console.log(`\n${'='.repeat(60)}`)
      console.log(`Running ${name}...`)
      console.log('='.repeat(60))
      try {
        await runScript(path.join(categoryDir, scriptFile))
      } catch (error) {
        console.error(`\n‚ùå ${name} failed:`, error.message)
        process.exit(1)
      }
    }

    console.log(`\n${'='.repeat(60)}`)
    console.log(`‚úÖ All ${categoryName} scripts completed successfully!`)
    console.log('='.repeat(60))
  }
}

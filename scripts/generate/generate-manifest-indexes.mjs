#!/usr/bin/env node

/**
 * Generate Manifest Index Files
 *
 * This script automatically generates TypeScript index files for each manifest type.
 * It scans the manifests directory and creates aggregated exports in src/lib/manifests/
 *
 * Usage: node scripts/generate-manifest-indexes.mjs
 */

import { execSync } from 'node:child_process'
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const MANIFESTS_DIR = path.join(__dirname, '../../manifests')
const OUTPUT_DIR = path.join(__dirname, '../../src/lib/generated')

// Manifest types to process
const MANIFEST_TYPES = ['ides', 'clis', 'models', 'providers', 'extensions', 'vendors']

/**
 * Ensure directory exists
 */
function ensureDir(dirPath) {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true })
    console.log(`‚úì Created directory: ${dirPath}`)
  }
}

/**
 * Convert kebab-case id to PascalCase variable name
 */
function toPascalCase(str) {
  return str
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join('')
}

/**
 * Get all JSON files in a directory
 */
function getJsonFiles(dirPath) {
  if (!fs.existsSync(dirPath)) {
    return []
  }
  return fs
    .readdirSync(dirPath)
    .filter(file => file.endsWith('.json'))
    .sort()
}

/**
 * Generate index file for a manifest type
 */
function generateIndexFile(typeName) {
  const typeDir = path.join(MANIFESTS_DIR, typeName)
  const files = getJsonFiles(typeDir)

  if (files.length === 0) {
    console.log(`‚ö† No JSON files found in ${typeName}/`)
    return
  }

  // Generate import statements - sort alphabetically by variable name
  const importData = files.map(file => {
    const id = file.replace('.json', '')
    const varName = toPascalCase(id)
    const relativePath = `../../../manifests/${typeName}/${file}`
    return { varName, statement: `import ${varName} from '${relativePath}'` }
  })

  // Sort imports alphabetically by variable name
  importData.sort((a, b) => a.varName.localeCompare(b.varName))
  const imports = importData.map(item => item.statement).join('\n')

  // Generate array export using sorted variable names
  const arrayItems = importData.map(item => item.varName).join(',\n  ')

  // Generate type name (singular)
  const typeSingular = typeName.replace(/s$/, '')
  const TypeName = toPascalCase(typeSingular)

  // Get the first file (alphabetically) to extract type
  const firstVarName = importData[0].varName

  // Add appropriate type import based on manifest type
  const typeImportMap = {
    ides: 'ManifestIDE',
    clis: 'ManifestCLI',
    models: 'ManifestModel',
    providers: 'ManifestProvider',
    extensions: 'ManifestExtension',
    vendors: 'ManifestVendor',
  }

  const manifestType = typeImportMap[typeName]
  const typeImport = manifestType
    ? `import type { ${manifestType} } from '../../types/manifests'\n`
    : ''

  const content = `/**
 * Auto-generated manifest index for ${typeName}
 * Generated by scripts/generate-manifest-indexes.mjs
 * Do not edit manually - run the script to regenerate
 */

${imports}
${typeImport}
export const ${typeName}Data = [
  ${arrayItems},
]${manifestType ? ` as unknown as ${manifestType}[]` : ''}

export type ${TypeName} = typeof ${firstVarName}

export default ${typeName}Data
`

  const outputPath = path.join(OUTPUT_DIR, `${typeName}.ts`)
  fs.writeFileSync(outputPath, content, 'utf8')
  console.log(`‚úì Generated ${typeName}.ts (${files.length} entries)`)
}

/**
 * Generate main index.ts file that exports all manifests
 */
function generateMainIndex() {
  // Generate all export statements
  const exportStatements = []
  for (const typeName of MANIFEST_TYPES) {
    const typeSingular = toPascalCase(typeName.replace(/s$/, ''))
    exportStatements.push({
      type: `export type { ${typeSingular} } from './${typeName}'`,
      data: `export { ${typeName}Data } from './${typeName}'`,
    })
  }

  // Sort exports alphabetically by type name and maintain type-before-data order
  const sortedExports = exportStatements
    .sort((a, b) => {
      const typeA = a.type.match(/\{ (\w+) \}/)[1]
      const typeB = b.type.match(/\{ (\w+) \}/)[1]
      return typeA.localeCompare(typeB)
    })
    .flatMap(item => [item.type, item.data])
    .join('\n')

  const content = `/**
 * Auto-generated main manifest index
 * Generated by scripts/generate-manifest-indexes.mjs
 * Do not edit manually - run the script to regenerate
 */

${sortedExports}
`

  const outputPath = path.join(OUTPUT_DIR, 'index.ts')
  fs.writeFileSync(outputPath, content, 'utf8')
  console.log(`‚úì Generated index.ts`)
}

/**
 * Generate GitHub stars TypeScript file from centralized JSON
 */
function generateGithubStarsFile() {
  const githubStarsPath = path.join(__dirname, '..', '..', 'data', 'github-stars.json')

  if (!fs.existsSync(githubStarsPath)) {
    console.log('‚ö† github-stars.json not found, skipping stars generation')
    return
  }

  const starsData = JSON.parse(fs.readFileSync(githubStarsPath, 'utf8'))

  const content = `/**
 * Auto-generated GitHub stars data
 * Generated by scripts/generate-manifest-indexes.mjs
 * Do not edit manually - run the script to regenerate
 */

import githubStarsJson from '../../../data/github-stars.json'

export type GithubStarsData = Record<string, Record<string, number | null>>

export const githubStarsData = githubStarsJson as GithubStarsData

/**
 * Get GitHub stars for a specific product
 * @param category - The product category (extensions, clis, ides)
 * @param id - The product ID
 * @returns The number of stars (in thousands) or null if not available
 */
export function getGithubStars(category: string, id: string): number | null {
  return githubStarsData[category]?.[id] ?? null
}

export default githubStarsData
`

  const outputPath = path.join(OUTPUT_DIR, 'github-stars.ts')
  fs.writeFileSync(outputPath, content, 'utf8')

  // Count total entries
  const totalEntries = Object.values(starsData).reduce((sum, category) => {
    return sum + Object.keys(category).length
  }, 0)

  console.log(`‚úì Generated github-stars.ts (${totalEntries} entries)`)
}

/**
 * Main execution
 */
function main() {
  console.log('='.repeat(60))
  console.log('Generate Manifest Index Files')
  console.log('='.repeat(60))

  // Ensure output directory exists
  ensureDir(OUTPUT_DIR)

  console.log('\nüìù Generating index files...\n')

  // Generate index file for each type
  for (const typeName of MANIFEST_TYPES) {
    generateIndexFile(typeName)
  }

  // Generate main index
  console.log('')
  generateMainIndex()

  // Generate GitHub stars file
  console.log('')
  generateGithubStarsFile()

  console.log(`\n${'='.repeat(60)}`)
  console.log('‚úÖ All index files generated successfully!')
  console.log('='.repeat(60))

  // Run biome formatting on generated files
  console.log(`\nüé® Formatting generated files with Biome...`)
  try {
    execSync(`npx biome format --write ${OUTPUT_DIR}`, {
      cwd: path.join(__dirname, '../..'),
      stdio: 'inherit',
    })
    console.log(`‚úÖ Formatting complete`)
  } catch (error) {
    console.error(`‚ö†Ô∏è  Biome formatting failed:`, error.message)
  }
}

// Run the script
try {
  main()
} catch (error) {
  console.error('\n‚ùå Error generating index files:', error.message)
  console.error(error.stack)
  process.exit(1)
}
